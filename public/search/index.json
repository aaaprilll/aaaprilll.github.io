[{"content":"\r前言\n连续登录问题在实际生产过程中可能会有许多不同的变种，实际上底层都为连续登录问题。 基本使用窗口函数来解决此类问题，row_number() rank() dense_rank() lead() lag() 等函数在连续登录问题中为高频函数。 本篇为实际生产中遇到的连续登录问题的变种场景。 需求描述\r以下以直播场景为例。\n场景\r用户使用产品过程中，可能会出现多级场景深入的情况，比如平台上了一个新的直播扶持项目(project)，该项目可能会进行多期计划(plan)，直播扶持项目的主播可以选择其中一期或者多期计划(plan)来参加，每期计划(plan)下可以开启多场直播(live)，用户进入直播间观看直播。\n需求\r某主播已经在一个项目(project)的第一期计划(plan)下进行了多场直播(live)，现在想要提取数据，获取每场直播有多少新用户，多少留存用户。\n新用户：在本plan下，第一次进入其中一场live的，即为新用户。\n留存用户：在本plan下，上一场live观看，本场live又观看的，即为留存用户。非n-1场的历史live观看过，本场live也观看的，不算留存用户。仅有n和n-1场live都观看的用户，才作为留存用户。\n建模分析\rproject、plan、live关系如图\n题外话在这个实体关系中聊点建模的内容\n这种多层级关系其实是非常适合建模成为dim层的维度表的，因为三个概念提供了非常丰富的上下文信息，但是在建模的时候也需要考虑一些情况和维度表怎么设计。\n类似这种多层级其实可以有两种维度表设计：\n一种是project、plan、live分别抽象成为维度表dim_project dim_plan dim_live，在三个维度表中使用id进行关联。\n优点：\n这种抽象方式的好处是可以清晰定义各个层级之间的关系，在分析的时候通过维度层次结构来向下一级一级钻取。在单独进行高维度的数据分析的时候（比如单独进行项目维度的分析时），数据不会冗余，不需要进行group by或者distinct去重。 可维护性比较高，能够保持维度表独立，单维度信息变化可以直接维护。 不会存在过多的数据冗余。 一种是project、plan、live抽象成一张dim的大宽表dim_project_plan_live。\n优点：\n这种抽象方式对于live粒度，或者多粒度的分析的时候，聚合非常方便，因为一个宽表中包含了所有相关的维度信息。在live粒度轻度聚合成dws层表之后，可以在dws_live的基础上进一步聚合成dws_plan dws_project, 减少了查询的复杂性，不需要join多张dim表，在相对比较小的数据集的时候性能会比上面那种更高。 在多种业务场景都共用该维度关系时，抽象成大宽表能够有效减少开发时间，提高开发效率。 缺点：\n一张大宽表势必会造成数据冗余，维护了更细粒度的live粒度的情况下，上层的project和plan会有大量重复数据。 当前业务场景下，project和plan的信息不会频繁变化，但如果切换成上级节点信息会频繁变化的场景，就需要频繁更新宽表中的数据。 随着业务发展，project和plan的结构发生变化，比如新增字段的时候，维护起来会更复杂，除了新增字段还需要重跑任务来更新dim的数据，在大数据量的场景下，etl花费的时间会变多，维护成本比较高。 在这个业务场景下，该维度建模在之前的其他业务场景中已经完成了，使用的是第二种，抽象成一张大的dim宽表的形式。原因如下：\n该业务涉及到的维度层级不会频繁变化，project、plan创建完毕并成功发布后，信息几乎不会变更。更新频率低。 该业务涉及到的维度层级，在其他的分析场景中也会使用，plan下不只有live，可能会有node、file等其他的节点类型，在多分析场景的情况下，直接建模大宽表能有效降低开发时间，否则每个业务条线的SQL都需要挨个关联project、plan等。复用程度高。 业务数据量级增长缓慢。 运营侧在针对live级别的数据查看报表的时候，需要plan、project级别的冗余数据辅助筛选项目信息（如项目开始时间，项目创建者，计划期数等）。 该维度关系不关心project、plan、live的信息变化，只需要信息快照，因此可以通过lifecycle完成数据生命周期管理，避免存储占用过高。 该业务的原始数据表在表设计中已经有关联思想，即project表、plan表、live表分别有id互相关联。 解法\r新用户\r如果计算一个计划下有多少新用户，可以直接对user进行count(distinct user_id)即可，但本需求需要计算每场直播有多少该计划下的新用户。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 SELECT project_id ,plan_id ,live_id ,count(user_id) first_user_cnt FROM ( SELECT project_id ,plan_id ,user_id ,live_id ,RANK() OVER (PARTITION BY project_id,plan_id,user_id ORDER BY live_id ASC) rk FROM dws_live_user -- 聚合了维度信息、用户观看数据的dws表 ) WHERE rk = 1 GROUP BY project_id ,plan_id ,live_id 留存用户\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 SELECT project_id ,plan_period ,node_id ,COUNT(DISTINCT user_id) user_cnt_2lives FROM ( SELECT a.* ,lag(b.rk,1,-99999999) OVER(PARTITION BY a.project_id,a.plan_id,a.user_id ORDER BY b.rk ASC) lead_rk ,b.rk - lag(b.rk,1,-99999999) OVER(PARTITION BY a.project_id,a.plan_id,a.user_id ORDER BY b.rk ASC) rk_diff FROM ( SELECT a.project_id ,a.plan_id ,b.plan_period ,a.node_id ,b.user_id ,dense_RANK() OVER(PARTITION BY a.project_id,a.plan_id,b.user_id ORDER BY a.node_id ASC ) rk FROM dim_community_space_project_info a JOIN dws_famous_school_online_living_user_watch_statistics b ON a.node_id = b.node_id AND b.ds = ${bizdate} WHERE a.ds = ${bizdate} AND (b.in_live_study_time \u0026lt;\u0026gt; 0 OR b.app_name NOT IN (\u0026#39;0\u0026#39;,\u0026#39;stkj\u0026#39;)) ) a LEFT JOIN ( SELECT project_id ,plan_id ,node_id ,COUNT(DISTINCT node_id) OVER(PARTITION BY project_id,plan_id) max_rk ,dense_RANK() OVER(PARTITION BY project_id,plan_id ORDER BY node_id ASC ) rk FROM dim_community_space_project_info WHERE ds = ${bizdate} AND node_start_date \u0026lt; \u0026#39;${date}\u0026#39; ) b ON a.project_id = b.project_id AND a.plan_id = b.plan_id AND a.node_id = b.node_id ) WHERE rk_diff = 1 GROUP BY project_id ,plan_period ,node_id ; ","date":"2025-05-07T00:00:00Z","permalink":"http://localhost:1313/p/%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/","title":"用户连续登录/访问/观看/留存问题思考"}]